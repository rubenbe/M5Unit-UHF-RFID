esphome:
  name: m5core2
  friendly_name: M5Core2
  min_version: 2025.12.0
  includes:
    - src/RFID_command.h
    - M5RFID.h
    - src/RFID_command.cpp
    - src/RFID_command_basics.cpp
    - src/my_helpers.h
    - src/my_helpers.cpp
  on_boot:
    - priority: 600
      then:
        - delay: 300ms
        - light.turn_on:
            id: backlight_light
            brightness: !lambda return id(saved_brightness);
    - priority: 800
      then:
        - lambda: |-
            auto cause = esp_sleep_get_wakeup_cause();
            ESP_LOGW("wakeup", "Wakeup cause: %d", (int)cause);

esp32:
  board: m5stack-core2
  framework:
    type: arduino

psram:
  mode: quad
  speed: 80MHz

logger:
  level: DEBUG
  logs:
    sensor: INFO
    text_sensor: INFO


api:

ota:
  - platform: esphome
    password: !secret ota_password

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  ap:
    ssid: "M5Core2 Fallback"
    password: !secret fallback_ap_password

captive_portal:

time:
  - platform: sntp
    id: sntp_time
    timezone: Europe/Warsaw

datetime:
  - platform: template
    name: "Set RTC"
    id: rtc_set
    type: datetime
    optimistic: true
    on_value:
      - lambda: |-
          struct timeval tv;
          tv.tv_sec = x.timestamp;
          tv.tv_usec = 0;
          settimeofday(&tv, nullptr);
          ESP_LOGI("rtc", "RTC set to %04d-%02d-%02d %02d:%02d:%02d",
                   x.year, x.month, x.day_of_month, x.hour, x.minute, x.second);

# TBD: Disable for production
web_server:
  port: 80

i2c:
  - id: bus_a
    sda: GPIO21
    scl: GPIO22
    # TBD: set to false for production
    scan: true

i2c_device:
  id: axp_raw
  address: 0x34
  i2c_id: bus_a

external_components:
  - source: github://Cyklon79/esphome-axp2101
    components: [ axp2101 ]
    refresh: 0s
  - source:
      type: local
      path: esphome/components
    components: [m5rfid]

globals:
  - id: battery_is_charging
    type: bool
    restore_value: no
    initial_value: 'false'
  - id: v_filt
    type: float
    restore_value: no
    initial_value: '0.0'
  - id: slope_filt_vph
    type: float
    restore_value: no
    initial_value: '0.0'
  - id: v_prev
    type: float
    restore_value: no
    initial_value: '0.0'
  - id: stable_counter
    type: int
    restore_value: no
    initial_value: '0'
  - id: mode
    type: int          # 0=DETECTING, 1=CHARGING, 2=FULL, 3=DISCHARGING
    restore_value: no
    initial_value: '0'
  - id: last_pwr_ms
    type: uint32_t
    restore_value: no
    initial_value: '0'
  - id: saved_brightness
    type: float
    restore_value: yes
    initial_value: '0.6'   # domyślna jasność po pierwszym starcie
  - id: tag_list
    type: std::vector<std::string>
    restore_value: no
  - id: unique_epcs
    type: std::set<std::string>
    restore_value: no

switch:
  - platform: template
    name: "Core2 Allow PowerOff"
    id: allow_poweroff
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF

  - platform: template
    name: "Buzzer"
    id: buzzer_switch
    optimistic: true
    turn_on_action:
      - rtttl.play:
          rtttl: 'two_beeps:d=4,o=5,b=100:16e6,16p,16e6'
    turn_off_action:
      - rtttl.stop



deep_sleep:
  id: deep_sleep_ctrl
  wakeup_pin:
    number: GPIO39
    inverted: true

script:
  - id: melody
    then:
      - rtttl.play:
          rtttl: 'two_beeps:d=4,o=5,b=100:16e6,16p,16e6'

  - id: power_off
    mode: single
    then:
      - lambda: |-
          // zapisz aktualną jasność (0.0 .. 1.0)
          float b = id(backlight_light).current_values.get_brightness();
          if (b > 0.01f) id(saved_brightness) = b;
          ESP_LOGD("pwr", "Saved brightness=%.3f", id(saved_brightness));
          id(axp_comp).set_brightness(0.0f);
      - logger.log: "POWER_OFF requested -> entering deep sleep in 1s"
#      - light.turn_off: backlight_light
      - delay: 1s
      - deep_sleep.enter: deep_sleep_ctrl


text_sensor:
  - platform: template
    name: "Battery Mode"
    id: battery_mode

  - platform: m5rfid
    name: "RFID"
    id: m5rfid_sensor
    rx_pin: 33
    tx_pin: 32
    on_value:
      then:
        - script.execute: melody
        - lambda: |-
            // Parse CSV: "EPC,RSSI"
            std::string val = x;
            auto comma = val.find(',');
            std::string epc = (comma != std::string::npos) ? val.substr(0, comma) : val;
            std::string rssi = (comma != std::string::npos) ? val.substr(comma + 1) : "";

            // Track unique EPCs (max 100)
            if (id(unique_epcs).size() < 100) {
              id(unique_epcs).insert(epc);
            }

            // Timestamp
            char ts[9] = "??:??:??";
            auto now = id(sntp_time).now();
            if (now.is_valid()) {
              snprintf(ts, sizeof(ts), "%02d:%02d:%02d", now.hour, now.minute, now.second);
            }

            // Show last 8 hex chars of EPC + RSSI + timestamp
            std::string short_epc = (epc.length() > 8) ? epc.substr(epc.length() - 8) : epc;
            std::string entry = std::string(ts) + " " + short_epc + " " + rssi + "dBm";

            // Prepend new tag
            id(tag_list).insert(id(tag_list).begin(), entry);
            // Cap at 8 entries on screen
            while (id(tag_list).size() > 8) {
              id(tag_list).pop_back();
            }

            // Update title with unique count
            char title[32];
            snprintf(title, sizeof(title), "RFID Tags (%d)", (int)id(unique_epcs).size());
            lv_label_set_text(id(lbl_title), title);

            // Build display string
            std::string display;
            for (size_t i = 0; i < id(tag_list).size(); i++) {
              if (i > 0) display += "\n";
              display += id(tag_list)[i];
            }
            lv_label_set_text(id(lbl_tags), display.c_str());

sensor:
  - platform: axp2101
    model: M5CORE2
    address: 0x34
    id: axp_comp
    i2c_id: bus_a
    update_interval: 10s
    battery_voltage:
      name: "Battery Voltage"
      id: battery_voltage
      device_class: voltage
      unit_of_measurement: "V"
      state_class: measurement
    battery_level:
      name: "Battery Level"
      id: battery_level_id
      device_class: battery
      unit_of_measurement: "%"
      state_class: measurement

binary_sensor:
  - platform: status
    name: "M5Core2 Status"
    entity_category: diagnostic


output:
  - platform: ledc
    pin: GPIO2
    id: buzzer_out

  - platform: template
    id: backlight_out
    type: float
    write_action:
      - lambda: |-
          ESP_LOGD("pwr", "Backlight write_action state=%.3f", state);
          // state: 0.0 .. 1.0
          id(axp_comp).set_brightness(state);

rtttl:
  output: buzzer_out
  id: buzzer

light:
  - platform: monochromatic
    name: "M5Core2 Backlight"
    id: backlight_light
    icon: "mdi:brightness-6"
    output: backlight_out
    gamma_correct: 1.0
    restore_mode: RESTORE_DEFAULT_ON
    on_state:
      - component.update: lcd

# --- SPI (ekran) ---
spi:
  clk_pin: GPIO18
  mosi_pin: GPIO23
  miso_pin: GPIO38

font:
  - file: "gfonts://Roboto"
    id: roboto
    size: 18

display:
  - platform: mipi_spi
    id: lcd
    model: M5CORE2
    auto_clear_enabled: false
    update_interval: never

touchscreen:
  - platform: ft63x6
    id: ts
    i2c_id: bus_a
    address: 0x38
    display: lcd
    update_interval: 50ms
    # interrupt_pin: GPIO39

    on_touch:
      then:
        - lambda: |-
            const uint32_t now = millis();
            if (now - id(last_pwr_ms) < 800) return;

            const int x = touch.x;
            const int y = touch.y;

            // Twoje logi dla B: x≈156, y=239
            // Środek (107..213) i sam dół ekranu (>=232)
            if (x >= 107 && x <= 213 && y >= 232) {
              id(last_pwr_ms) = now;
              ESP_LOGW("pwr", "TouchB detected (x=%d y=%d) -> power_off()", x, y);
              id(power_off).execute();
            }

interval:
  - interval: 30s
    then:
      - lambda: |-
          const float dt_s = 30.0f;
          // Jeśli chcesz ograniczyć false-positive, odkomentuj i licz trend tylko przy stabilnym obciążeniu, np. gdy ekran off:
          // if (id(display_backlight).current_values.is_on()) return;

          float v = id(battery_voltage).state;
          if (!isfinite(v) || v < 2.5f || v > 4.5f) return;

          if (id(v_filt) <= 0.01f) {
            id(v_filt) = v;
            id(v_prev) = v;
            id(slope_filt_vph) = 0.0f;
            id(battery_mode).publish_state("DETECTING");
            return;
          }

          // 1) EMA napięcia
          const float a_v = 0.2f;
          id(v_filt) = (a_v * v) + ((1.0f - a_v) * id(v_filt));

          // 2) Trend w V/h 
          float dv = id(v_filt) - id(v_prev);
          id(v_prev) = id(v_filt);
          float slope_vph = dv * (3600.0f / dt_s);

          // 3) EMA trendu
          const float a_s = 0.3f;
          id(slope_filt_vph) = (a_s * slope_vph) + ((1.0f - a_s) * id(slope_filt_vph));

          // Progi
          const float V_FULL = 4.15f;
          const float V_FULL_HI = 0.02f;   // histereza górą
          const float V_CHG_HI  = 0.03f;   // histereza do ładowania (poniżej)
          const float S_POS = 0.010f;      // +10 mV/h
          const float S_NEG = -0.010f;     // -10 mV/h
          const float S_FLAT = 0.100f;

          // Logika stanowa z licznikami
          int new_mode = id(mode);

          bool want_charging = (id(v_filt) < (V_FULL - V_CHG_HI)) && (id(slope_filt_vph) > S_POS);
          bool want_full     = (id(v_filt) > (V_FULL + V_FULL_HI)) && (fabsf(id(slope_filt_vph)) < S_FLAT);
          bool want_dis      = (id(slope_filt_vph) < S_NEG);

          // Priorytet: FULL > CHARGING > DISCHARGING
          int candidate = 0;
          if (want_full) candidate = 2;
          else if (want_charging) candidate = 1;
          else if (want_dis) candidate = 3;
          else candidate = 0;

          if (candidate == id(mode)) {
            id(stable_counter) = 0; // już jesteśmy w tym stanie
          } else {
            id(stable_counter)++;
            // minimalny czas potwierdzenia
            int req = 1;
            if (candidate == 2) req = 2; // FULL
            else if (candidate == 1 || candidate == 3) req = 3; // CHG/DIS: 
            else req = 3; // DETECTING: 

            if (id(stable_counter) >= req) {
              new_mode = candidate;
              id(stable_counter) = 0;
            }
          }

          id(mode) = new_mode;

          // Publikacja trybu + ustawienie Twojej flagi do ikonki
          const char* txt = "DETECTING";
          if (id(mode) == 1) txt = "CHARGING";
          else if (id(mode) == 2) txt = "FULL";
          else if (id(mode) == 3) txt = "DISCHARGING";
          id(battery_mode).publish_state(txt);

          id(battery_is_charging) = (id(mode) == 1);

lvgl:
  displays: [lcd]
  touchscreens:
    - touchscreen_id: ts

  pages:
    - id: main_page
      widgets:
        - obj:
            align: TOP_MID
            width: 320
            height: 240
            pad_all: 8
            bg_color: 0x000000
            bg_opa: COVER
            border_width: 0
            widgets:
              - label:
                  id: lbl_title
                  align: TOP_MID
                  text: "RFID Tags (0)"
                  text_color: 0x00E676
                  text_font: roboto
              - label:
                  id: lbl_tags
                  align: TOP_LEFT
                  y: 28
                  width: 304
                  text: "Waiting for tags..."
                  text_color: 0xFFFFFF
                  text_font: roboto

