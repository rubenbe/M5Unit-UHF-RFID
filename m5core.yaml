esphome:
  name: m5core2
  friendly_name: M5Core2
  min_version: 2025.12.0
  includes:
    - src/RFID_command.h
    - M5RFID.h
    - src/RFID_command.cpp
    - src/RFID_command_basics.cpp
    - src/my_helpers.h
    - src/my_helpers.cpp
    - sd_helper.h
  on_boot:
    - priority: 600
      then:
        - delay: 300ms
        - light.turn_on:
            id: backlight_light
            brightness: !lambda return id(saved_brightness);
        - lambda: 'sd_init(); sd_load_runners();'
    - priority: 800
      then:
        - lambda: |-
            auto cause = esp_sleep_get_wakeup_cause();
            ESP_LOGW("wakeup", "Wakeup cause: %d", (int)cause);
    - priority: -100
      then:
        - lambda: |-
            struct SdCsvHandler : public esphome::web_server_idf::AsyncWebHandler {
              std::string url_path;
              std::string sd_path;
              std::string filename;
              SdCsvHandler(const char *url, const char *sd, const char *fn)
                : url_path(url), sd_path(sd), filename(fn) {}
              bool canHandle(esphome::web_server_idf::AsyncWebServerRequest *request) const override {
                return request->url() == url_path;
              }
              void handleRequest(esphome::web_server_idf::AsyncWebServerRequest *request) override {
                if (!sd_ready) {
                  request->send(503, "text/plain", "SD card not available");
                  return;
                }
                FILE *f = fopen(sd_path.c_str(), "r");
                if (!f) {
                  request->send(404, "text/plain", "File not found");
                  return;
                }
                fseek(f, 0, SEEK_END);
                size_t sz = ftell(f);
                fseek(f, 0, SEEK_SET);
                std::string content(sz, '\0');
                fread(&content[0], 1, sz, f);
                fclose(f);
                std::string disp = "attachment; filename=\"" + filename + "\"";
                auto *resp = request->beginResponse(200, "text/csv", content);
                resp->addHeader("Content-Disposition", disp.c_str());
                request->send(resp);
              }
            };
            auto *srv = id(web_base)->get_server();
            srv->addHandler(new SdCsvHandler("/tags.csv", SD_TAG_FILE, "tags.csv"));
            srv->addHandler(new SdCsvHandler("/runners.csv", SD_RUNNERS_FILE, "runners.csv"));

esp32:
  board: m5stack-core2
  framework:
    type: arduino

psram:
  mode: quad
  speed: 80MHz

logger:
  level: DEBUG
  logs:
    sensor: INFO
    text_sensor: INFO


api:

ota:
  - platform: esphome
    password: !secret ota_password

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  ap:
    ssid: "M5Core2 Fallback"
    password: !secret fallback_ap_password

captive_portal:

time:
  - platform: pcf8563
    id: rtc_time
    i2c_id: bus_a
    address: 0x51
    timezone: Europe/Warsaw

  - platform: sntp
    id: sntp_time
    timezone: Europe/Warsaw
    on_time_sync:
      - pcf8563.write_time: rtc_time

datetime:
  - platform: template
    name: "Set RTC"
    id: rtc_set
    type: datetime
    optimistic: true
    on_value:
      - lambda: |-
          struct timeval tv;
          tv.tv_sec = x.timestamp;
          tv.tv_usec = 0;
          settimeofday(&tv, nullptr);
          ESP_LOGI("rtc", "RTC set to %04d-%02d-%02d %02d:%02d:%02d",
                   x.year, x.month, x.day_of_month, x.hour, x.minute, x.second);
      - pcf8563.write_time: rtc_time

# TBD: Disable for production
web_server_base:
  id: web_base

web_server:
  port: 80
  js_include: "web_custom.js"

i2c:
  - id: bus_a
    sda: GPIO21
    scl: GPIO22
    # TBD: set to false for production
    scan: true

i2c_device:
  id: axp_raw
  address: 0x34
  i2c_id: bus_a

external_components:
  - source: github://Cyklon79/esphome-axp2101
    components: [ axp2101 ]
    refresh: 0s
  - source:
      type: local
      path: esphome/components
    components: [m5rfid]

globals:
  - id: battery_is_charging
    type: bool
    restore_value: no
    initial_value: 'false'
  - id: v_filt
    type: float
    restore_value: no
    initial_value: '0.0'
  - id: slope_filt_vph
    type: float
    restore_value: no
    initial_value: '0.0'
  - id: v_prev
    type: float
    restore_value: no
    initial_value: '0.0'
  - id: stable_counter
    type: int
    restore_value: no
    initial_value: '0'
  - id: mode
    type: int          # 0=DETECTING, 1=CHARGING, 2=FULL, 3=DISCHARGING
    restore_value: no
    initial_value: '0'
  - id: last_pwr_ms
    type: uint32_t
    restore_value: no
    initial_value: '0'
  - id: saved_brightness
    type: float
    restore_value: yes
    initial_value: '0.6'   # domyślna jasność po pierwszym starcie
  - id: tag_order
    type: std::vector<std::string>
    restore_value: no
  - id: tag_times
    type: std::map<std::string, std::pair<std::string, std::string>>
    restore_value: no
  - id: last_tag_ms
    type: uint32_t
    restore_value: no
    initial_value: '0'
  - id: boot_logged
    type: bool
    restore_value: no
    initial_value: 'false'

switch:
  - platform: template
    name: "Core2 Allow PowerOff"
    id: allow_poweroff
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF

deep_sleep:
  id: deep_sleep_ctrl
  wakeup_pin:
    number: GPIO39
    inverted: true

script:
  - id: blink_led
    mode: restart
    then:
      - lambda: |-
          uint8_t reg;
          id(axp_raw).read_byte(0x69, &reg);
          id(axp_raw).write_byte(0x69, (reg & 0xC8) | 0x35);
      - delay: 100ms
      - lambda: |-
          uint8_t reg;
          id(axp_raw).read_byte(0x69, &reg);
          id(axp_raw).write_byte(0x69, (reg & 0xF9) | 0x01);

  - id: power_off
    mode: single
    then:
      - lambda: |-
          // zapisz aktualną jasność (0.0 .. 1.0)
          float b = id(backlight_light).current_values.get_brightness();
          if (b > 0.01f) id(saved_brightness) = b;
          ESP_LOGD("pwr", "Saved brightness=%.3f", id(saved_brightness));
          id(axp_comp).set_brightness(0.0f);
      - logger.log: "POWER_OFF requested -> entering deep sleep in 1s"
#      - light.turn_off: backlight_light
      - delay: 1s
      - deep_sleep.enter: deep_sleep_ctrl


text_sensor:
  - platform: template
    name: "Battery Mode"
    id: battery_mode

  - platform: m5rfid
    name: "RFID"
    id: m5rfid_sensor
    rx_pin: 33
    tx_pin: 32
    on_value:
      then:
        - if:
            condition:
              lambda: 'return id(rtc_time).now().is_valid();'
            then:
              - script.execute: blink_led
              - lambda: |-
                  id(last_tag_ms) = millis();
                  if (!id(backlight_light).current_values.is_on()) {
                    auto call = id(backlight_light).turn_on();
                    call.set_brightness(id(saved_brightness));
                    call.perform();
                  }
                  // Parse CSV: "EPC,RSSI"
                  std::string val = id(m5rfid_sensor).state;
                  auto comma = val.find(',');
                  std::string epc = (comma != std::string::npos) ? val.substr(0, comma) : val;

                  // Timestamps
                  char ts[9];
                  char ts_full[20];
                  auto now = id(rtc_time).now();
                  snprintf(ts, sizeof(ts), "%02d:%02d:%02d", now.hour, now.minute, now.second);
                  snprintf(ts_full, sizeof(ts_full), "%04d-%02d-%02d %02d:%02d:%02d",
                           now.year, now.month, now.day_of_month, now.hour, now.minute, now.second);
                  std::string ts_str(ts);

                  // Update first/last times (max 100 unique tags)
                  auto &times = id(tag_times);
                  auto it = times.find(epc);
                  if (it == times.end()) {
                    if (times.size() < 100) {
                      times[epc] = std::make_pair(ts_str, ts_str);
                      id(tag_order).insert(id(tag_order).begin(), epc);
                      if (!id(boot_logged)) {
                        id(boot_logged) = true;
                        sd_append_tag(0, ts_full, "BOOT", "");
                      }
                      std::string runner = sd_lookup_runner(epc);
                      sd_append_tag((int)times.size(), ts_full, epc.c_str(), runner.c_str());
                    }
                  } else {
                    it->second.second = ts_str;
                    auto &order = id(tag_order);
                    order.erase(std::remove(order.begin(), order.end(), epc), order.end());
                    order.insert(order.begin(), epc);
                  }

                  // Build display strings (left: tag+name, right: times)
                  std::string left, right;
                  auto &order = id(tag_order);
                  size_t limit = std::min(order.size(), (size_t)9);
                  for (size_t i = 0; i < limit; i++) {
                    if (i > 0) { left += "\n"; right += "\n"; }
                    auto &epc_key = order[i];
                    std::string short_epc = (epc_key.length() > 8) ? epc_key.substr(epc_key.length() - 8) : epc_key;
                    auto &t = times[epc_key];
                    std::string name = sd_lookup_runner(epc_key);
                    left += short_epc;
                    if (!name.empty()) left += " " + name;
                    right += t.first + "-" + t.second;
                  }
                  lv_label_set_text(id(lbl_tags), left.c_str());
                  lv_label_set_text(id(lbl_times), right.c_str());

sensor:
  - platform: axp2101
    model: M5CORE2
    address: 0x34
    id: axp_comp
    i2c_id: bus_a
    update_interval: 10s
    battery_voltage:
      name: "Battery Voltage"
      id: battery_voltage
      device_class: voltage
      unit_of_measurement: "V"
      state_class: measurement
    battery_level:
      name: "Battery Level"
      id: battery_level_id
      device_class: battery
      unit_of_measurement: "%"
      state_class: measurement

binary_sensor:
  - platform: status
    name: "M5Core2 Status"
    entity_category: diagnostic


output:
  - platform: template
    id: backlight_out
    type: float
    write_action:
      - lambda: |-
          ESP_LOGD("pwr", "Backlight write_action state=%.3f", state);
          // state: 0.0 .. 1.0
          id(axp_comp).set_brightness(state);

light:
  - platform: monochromatic
    name: "M5Core2 Backlight"
    id: backlight_light
    icon: "mdi:brightness-6"
    output: backlight_out
    gamma_correct: 1.0
    restore_mode: RESTORE_DEFAULT_ON
    on_state:
      - component.update: lcd

# --- SPI (ekran) ---
spi:
  clk_pin: GPIO18
  mosi_pin: GPIO23
  miso_pin: GPIO38

font:
  - file: "gfonts://Roboto"
    id: roboto
    size: 18

display:
  - platform: mipi_spi
    id: lcd
    model: M5CORE2
    auto_clear_enabled: false
    update_interval: never

touchscreen:
  - platform: ft63x6
    id: ts
    i2c_id: bus_a
    address: 0x38
    display: lcd
    update_interval: 50ms
    # interrupt_pin: GPIO39

    on_touch:
      then:
        - lambda: |-
            const uint32_t now = millis();
            if (now - id(last_pwr_ms) < 800) return;

            // Any touch wakes the screen
            if (!id(backlight_light).current_values.is_on()) {
              id(last_pwr_ms) = now;
              auto call = id(backlight_light).turn_on();
              call.set_brightness(id(saved_brightness));
              call.perform();
              id(last_tag_ms) = millis();
              return;
            }

            // Reset auto-off timer on any touch
            id(last_tag_ms) = millis();

            const int x = touch.x;
            const int y = touch.y;

            // TouchA (left button) - toggle backlight
            if (x < 107 && y >= 232) {
              id(last_pwr_ms) = now;
              if (id(backlight_light).current_values.is_on()) {
                auto call = id(backlight_light).turn_off();
                call.perform();
              } else {
                auto call = id(backlight_light).turn_on();
                call.set_brightness(id(saved_brightness));
                call.perform();
                id(last_tag_ms) = millis();
              }
            }

            // TouchB (middle button) - power off
            if (x >= 107 && x <= 213 && y >= 232) {
              id(last_pwr_ms) = now;
              ESP_LOGW("pwr", "TouchB detected (x=%d y=%d) -> power_off()", x, y);
              id(power_off).execute();
            }

interval:
  - interval: 1s
    then:
      - lambda: |-
          auto now = id(rtc_time).now();
          char title[48];
          if (now.is_valid()) {
            snprintf(title, sizeof(title), "RFID Tags (%d) %02d:%02d:%02d",
                     (int)id(tag_times).size(), now.hour, now.minute, now.second);
          } else {
            snprintf(title, sizeof(title), "RFID Tags (%d)", (int)id(tag_times).size());
          }
          lv_label_set_text(id(lbl_title), title);

          // SD indicator: green if OK, red if error, hidden if not attempted
          if (sd_ready) {
            lv_label_set_text(id(lbl_sd), "[SD]");
            lv_obj_set_style_text_color(id(lbl_sd), lv_color_hex(0x00E676), 0);
          } else if (sd_failed) {
            lv_label_set_text(id(lbl_sd), "[SD]");
            lv_obj_set_style_text_color(id(lbl_sd), lv_color_hex(0xFF0000), 0);
          }

          // Auto-off backlight 30s after last tag read
          if (id(last_tag_ms) > 0 &&
              (millis() - id(last_tag_ms)) > 30000 &&
              id(backlight_light).current_values.is_on()) {
            auto call = id(backlight_light).turn_off();
            call.perform();
          }

  - interval: 30s
    then:
      - lambda: |-
          const float dt_s = 30.0f;
          // Jeśli chcesz ograniczyć false-positive, odkomentuj i licz trend tylko przy stabilnym obciążeniu, np. gdy ekran off:
          // if (id(display_backlight).current_values.is_on()) return;

          float v = id(battery_voltage).state;
          if (!isfinite(v) || v < 2.5f || v > 4.5f) return;

          if (id(v_filt) <= 0.01f) {
            id(v_filt) = v;
            id(v_prev) = v;
            id(slope_filt_vph) = 0.0f;
            id(battery_mode).publish_state("DETECTING");
            return;
          }

          // 1) EMA napięcia
          const float a_v = 0.2f;
          id(v_filt) = (a_v * v) + ((1.0f - a_v) * id(v_filt));

          // 2) Trend w V/h 
          float dv = id(v_filt) - id(v_prev);
          id(v_prev) = id(v_filt);
          float slope_vph = dv * (3600.0f / dt_s);

          // 3) EMA trendu
          const float a_s = 0.3f;
          id(slope_filt_vph) = (a_s * slope_vph) + ((1.0f - a_s) * id(slope_filt_vph));

          // Progi
          const float V_FULL = 4.15f;
          const float V_FULL_HI = 0.02f;   // histereza górą
          const float V_CHG_HI  = 0.03f;   // histereza do ładowania (poniżej)
          const float S_POS = 0.010f;      // +10 mV/h
          const float S_NEG = -0.010f;     // -10 mV/h
          const float S_FLAT = 0.100f;

          // Logika stanowa z licznikami
          int new_mode = id(mode);

          bool want_charging = (id(v_filt) < (V_FULL - V_CHG_HI)) && (id(slope_filt_vph) > S_POS);
          bool want_full     = (id(v_filt) > (V_FULL + V_FULL_HI)) && (fabsf(id(slope_filt_vph)) < S_FLAT);
          bool want_dis      = (id(slope_filt_vph) < S_NEG);

          // Priorytet: FULL > CHARGING > DISCHARGING
          int candidate = 0;
          if (want_full) candidate = 2;
          else if (want_charging) candidate = 1;
          else if (want_dis) candidate = 3;
          else candidate = 0;

          if (candidate == id(mode)) {
            id(stable_counter) = 0; // już jesteśmy w tym stanie
          } else {
            id(stable_counter)++;
            // minimalny czas potwierdzenia
            int req = 1;
            if (candidate == 2) req = 2; // FULL
            else if (candidate == 1 || candidate == 3) req = 3; // CHG/DIS: 
            else req = 3; // DETECTING: 

            if (id(stable_counter) >= req) {
              new_mode = candidate;
              id(stable_counter) = 0;
            }
          }

          id(mode) = new_mode;

          // Publikacja trybu + ustawienie Twojej flagi do ikonki
          const char* txt = "DETECTING";
          if (id(mode) == 1) txt = "CHARGING";
          else if (id(mode) == 2) txt = "FULL";
          else if (id(mode) == 3) txt = "DISCHARGING";
          id(battery_mode).publish_state(txt);

          id(battery_is_charging) = (id(mode) == 1);

lvgl:
  displays: [lcd]
  touchscreens:
    - touchscreen_id: ts

  pages:
    - id: main_page
      widgets:
        - obj:
            align: TOP_MID
            width: 320
            height: 240
            pad_all: 8
            bg_color: 0x000000
            bg_opa: COVER
            border_width: 0
            radius: 0
            widgets:
              - label:
                  id: lbl_title
                  align: TOP_LEFT
                  text: "RFID Tags (0)"
                  text_color: 0x00E676
                  text_font: roboto
              - label:
                  id: lbl_sd
                  align: TOP_RIGHT
                  text: ""
                  text_font: roboto
              - label:
                  id: lbl_tags
                  align: TOP_LEFT
                  y: 28
                  text: "Waiting for tags..."
                  text_color: 0xFFFFFF
                  text_font: roboto
              - label:
                  id: lbl_times
                  align: TOP_RIGHT
                  y: 28
                  text_align: RIGHT
                  text: ""
                  text_color: 0xFFFFFF
                  text_font: roboto

