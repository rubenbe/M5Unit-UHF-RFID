esphome:
  name: m5core2
  friendly_name: M5Core2
  min_version: 2025.12.0
  on_boot:
    - priority: 600
      then:
        - delay: 300ms
        - light.turn_on:
            id: backlight_light
            brightness: !lambda return id(saved_brightness);
    - priority: 800
      then:
        - lambda: |-
            auto cause = esp_sleep_get_wakeup_cause();
            ESP_LOGW("wakeup", "Wakeup cause: %d", (int)cause);

esp32:
  board: m5stack-core2
  framework:
    type: arduino

psram:
  mode: quad
  speed: 80MHz

logger:
  level: DEBUG
  logs:
    sensor: INFO
    text_sensor: INFO

substitutions:
  l1_entity: "light.ws_sypialnia_lozko_l1"
  l2_entity: "light.ws_sypialnia_lozko_l2"
  l3_entity: "light.ws_sypialnia_przedsionek_l2"
  l4_entity: "light.sp_sypialnia_lampka_2"
  l1_name: "Lozko 1"
  l2_name: "Lozko 2"
  l3_name: "Przedsionek l2"
  l4_name: "Lampka"


api:

ota:
  - platform: esphome
    password: !secret ota_password

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  ap:
    ssid: "M5Core2 Fallback"
    password: !secret fallback_ap_password

captive_portal:

# TBD: Disable for production
web_server:
  port: 80

i2c:
  - id: bus_a
    sda: GPIO21
    scl: GPIO22
    # TBD: set to false for production
    scan: true

i2c_device:
  id: axp_raw
  address: 0x34
  i2c_id: bus_a

external_components:
  #- source: github://martydingo/esphome-axp192
  - source: github://Cyklon79/esphome-axp2101
    components: [ axp2101 ]

#external_components:
#  - source:
#      #type: local
#      #path: /config/esphome/my_components/esphome-axp2101/components
#    components: [ axp2101 ]
#    # TBD: Remove for production
    refresh: 0s

globals:
  - id: battery_is_charging
    type: bool
    restore_value: no
    initial_value: 'false'
  - id: v_filt
    type: float
    restore_value: no
    initial_value: '0.0'
  - id: slope_filt_vph
    type: float
    restore_value: no
    initial_value: '0.0'
  - id: v_prev
    type: float
    restore_value: no
    initial_value: '0.0'
  - id: stable_counter
    type: int
    restore_value: no
    initial_value: '0'
  - id: mode
    type: int          # 0=DETECTING, 1=CHARGING, 2=FULL, 3=DISCHARGING
    restore_value: no
    initial_value: '0'
  - id: last_pwr_ms
    type: uint32_t
    restore_value: no
    initial_value: '0'
  - id: saved_brightness
    type: float
    restore_value: yes
    initial_value: '0.6'   # domyślna jasność po pierwszym starcie

switch:
  - platform: template
    name: "Core2 Allow PowerOff"
    id: allow_poweroff
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF

  - platform: template
    name: "Buzzer"
    id: buzzer_switch
    optimistic: true
    turn_on_action:
      - rtttl.play:
          rtttl: 'two_beeps:d=4,o=5,b=100:16e6,16p,16e6'
    turn_off_action:
      - rtttl.stop



deep_sleep:
  id: deep_sleep_ctrl
  wakeup_pin:
    number: GPIO39
    inverted: true

script:
  - id: power_off
    mode: single
    then:
      - lambda: |-
          // zapisz aktualną jasność (0.0 .. 1.0)
          float b = id(backlight_light).current_values.get_brightness();
          if (b > 0.01f) id(saved_brightness) = b;
          ESP_LOGD("pwr", "Saved brightness=%.3f", id(saved_brightness));
          id(axp_comp).set_brightness(0.0f);
      - logger.log: "POWER_OFF requested -> entering deep sleep in 1s"
#      - light.turn_off: backlight_light
      - delay: 1s
      - deep_sleep.enter: deep_sleep_ctrl


text_sensor:
  - platform: template
    name: "Battery Mode"
    id: battery_mode

sensor:
  - platform: axp2101
    model: M5CORE2
    address: 0x34
    id: axp_comp
    i2c_id: bus_a
    update_interval: 10s
    battery_voltage:
      name: "Battery Voltage"
      id: battery_voltage
      device_class: voltage
      unit_of_measurement: "V"
      state_class: measurement
    battery_level:
      name: "Battery Level"
      id: battery_level_id
      device_class: battery
      unit_of_measurement: "%"
      state_class: measurement

binary_sensor:
  - platform: status
    name: "M5Core2 Status"
    entity_category: diagnostic

  - platform: homeassistant
    id: ha_l1
    entity_id: ${l1_entity}
    publish_initial_state: true
    on_state:
      then:
        - lvgl.widget.update:
            id: btn_l1
            state:
              checked: !lambda return x;
        - lvgl.label.update:
            id: lbl_l1
            text: !lambda |-
              return std::string("${l1_name}\n") + (x ? "ON" : "OFF");

  - platform: homeassistant
    id: ha_l2
    entity_id: ${l2_entity}
    publish_initial_state: true
    on_state:
      then:
        - lvgl.widget.update:
            id: btn_l2
            state:
              checked: !lambda return x;
        - lvgl.label.update:
            id: lbl_l2
            text: !lambda |-
              return std::string("${l2_name}\n") + (x ? "ON" : "OFF");

  - platform: homeassistant
    id: ha_l3
    entity_id: ${l3_entity}
    publish_initial_state: true
    on_state:
      then:
        - lvgl.widget.update:
            id: btn_l3
            state:
              checked: !lambda return x;
        - lvgl.label.update:
            id: lbl_l3
            text: !lambda |-
              return std::string("${l3_name}\n") + (x ? "ON" : "OFF");

  - platform: homeassistant
    id: ha_l4
    entity_id: ${l4_entity}
    publish_initial_state: true
    on_state:
      then:
        - lvgl.widget.update:
            id: btn_l4
            state:
              checked: !lambda return x;
        - lvgl.label.update:
            id: lbl_l4
            text: !lambda |-
              return std::string("${l4_name}\n") + (x ? "ON" : "OFF");


output:
  - platform: ledc
    pin: GPIO2
    id: buzzer_out

  - platform: template
    id: backlight_out
    type: float
    write_action:
      - lambda: |-
          ESP_LOGD("pwr", "Backlight write_action state=%.3f", state);
          // state: 0.0 .. 1.0
          id(axp_comp).set_brightness(state);

rtttl:
  output: buzzer_out
  id: buzzer

light:
  - platform: monochromatic
    name: "M5Core2 Backlight"
    id: backlight_light
    icon: "mdi:brightness-6"
    output: backlight_out
    gamma_correct: 1.0
    restore_mode: RESTORE_DEFAULT_ON
    on_state:
      - component.update: lcd

# --- SPI (ekran) ---
spi:
  clk_pin: GPIO18
  mosi_pin: GPIO23
  miso_pin: GPIO38

font:
  - file: "gfonts://Roboto"
    id: roboto
    size: 24

display:
  - platform: mipi_spi
    id: lcd
    model: M5CORE2
    auto_clear_enabled: false
    update_interval: never

touchscreen:
  - platform: ft63x6
    id: ts
    i2c_id: bus_a
    address: 0x38
    display: lcd
    update_interval: 50ms
    # interrupt_pin: GPIO39

    on_touch:
      then:
        - lambda: |-
            const uint32_t now = millis();
            if (now - id(last_pwr_ms) < 800) return;

            const int x = touch.x;
            const int y = touch.y;

            // Twoje logi dla B: x≈156, y=239
            // Środek (107..213) i sam dół ekranu (>=232)
            if (x >= 107 && x <= 213 && y >= 232) {
              id(last_pwr_ms) = now;
              ESP_LOGW("pwr", "TouchB detected (x=%d y=%d) -> power_off()", x, y);
              id(power_off).execute();
            }

interval:
  - interval: 30s
    then:
      - lambda: |-
          const float dt_s = 30.0f;
          // Jeśli chcesz ograniczyć false-positive, odkomentuj i licz trend tylko przy stabilnym obciążeniu, np. gdy ekran off:
          // if (id(display_backlight).current_values.is_on()) return;

          float v = id(battery_voltage).state;
          if (!isfinite(v) || v < 2.5f || v > 4.5f) return;

          if (id(v_filt) <= 0.01f) {
            id(v_filt) = v;
            id(v_prev) = v;
            id(slope_filt_vph) = 0.0f;
            id(battery_mode).publish_state("DETECTING");
            return;
          }

          // 1) EMA napięcia
          const float a_v = 0.2f;
          id(v_filt) = (a_v * v) + ((1.0f - a_v) * id(v_filt));

          // 2) Trend w V/h 
          float dv = id(v_filt) - id(v_prev);
          id(v_prev) = id(v_filt);
          float slope_vph = dv * (3600.0f / dt_s);

          // 3) EMA trendu
          const float a_s = 0.3f;
          id(slope_filt_vph) = (a_s * slope_vph) + ((1.0f - a_s) * id(slope_filt_vph));

          // Progi
          const float V_FULL = 4.15f;
          const float V_FULL_HI = 0.02f;   // histereza górą
          const float V_CHG_HI  = 0.03f;   // histereza do ładowania (poniżej)
          const float S_POS = 0.010f;      // +10 mV/h
          const float S_NEG = -0.010f;     // -10 mV/h
          const float S_FLAT = 0.100f;

          // Logika stanowa z licznikami
          int new_mode = id(mode);

          bool want_charging = (id(v_filt) < (V_FULL - V_CHG_HI)) && (id(slope_filt_vph) > S_POS);
          bool want_full     = (id(v_filt) > (V_FULL + V_FULL_HI)) && (fabsf(id(slope_filt_vph)) < S_FLAT);
          bool want_dis      = (id(slope_filt_vph) < S_NEG);

          // Priorytet: FULL > CHARGING > DISCHARGING
          int candidate = 0;
          if (want_full) candidate = 2;
          else if (want_charging) candidate = 1;
          else if (want_dis) candidate = 3;
          else candidate = 0;

          if (candidate == id(mode)) {
            id(stable_counter) = 0; // już jesteśmy w tym stanie
          } else {
            id(stable_counter)++;
            // minimalny czas potwierdzenia
            int req = 1;
            if (candidate == 2) req = 2; // FULL
            else if (candidate == 1 || candidate == 3) req = 3; // CHG/DIS: 
            else req = 3; // DETECTING: 

            if (id(stable_counter) >= req) {
              new_mode = candidate;
              id(stable_counter) = 0;
            }
          }

          id(mode) = new_mode;

          // Publikacja trybu + ustawienie Twojej flagi do ikonki
          const char* txt = "DETECTING";
          if (id(mode) == 1) txt = "CHARGING";
          else if (id(mode) == 2) txt = "FULL";
          else if (id(mode) == 3) txt = "DISCHARGING";
          id(battery_mode).publish_state(txt);

          id(battery_is_charging) = (id(mode) == 1);

lvgl:
  displays: [lcd]
  touchscreens:
    - touchscreen_id: ts

  theme:
    button:
      bg_color: 0x303030        # OFF
      text_color: 0xFFFFFF
      border_width: 0
      bg_opa: COVER
      checked:                  # ON
        bg_color: 0x1B5E20
        text_color: 0xFFFFFF

  style_definitions:
    - id: light_btn
      radius: 16
      pad_all: 10
      outline_width: 0

    - id: grid_root
      pad_all: 10
      bg_opa: TRANSP
      border_opa: TRANSP

  pages:
    - id: main_page
      widgets:
        - obj:
            align: CENTER
            width: 320
            height: 240
            styles: grid_root
            layout:
              type: GRID
              grid_columns: [FR(1), FR(1)]
              grid_rows: [FR(1), FR(1)]
              pad_row: 10
              pad_column: 10

            widgets:
              - button:
                  id: btn_l1
                  checkable: true
                  styles: light_btn
                  grid_cell_column_pos: 0
                  grid_cell_row_pos: 0
                  grid_cell_x_align: STRETCH
                  grid_cell_y_align: STRETCH
                  widgets:
                    - label:
                        id: lbl_l1
                        align: CENTER
                        text: "${l1_name}\n--"
                  on_click:
                    - homeassistant.action:
                        action: light.toggle
                        data:
                          entity_id: ${l1_entity}

              - button:
                  id: btn_l2
                  checkable: true
                  styles: light_btn
                  grid_cell_column_pos: 1
                  grid_cell_row_pos: 0
                  grid_cell_x_align: STRETCH
                  grid_cell_y_align: STRETCH
                  widgets:
                    - label:
                        id: lbl_l2
                        align: CENTER
                        text: "${l2_name}\n--"
                  on_click:
                    - homeassistant.action:
                        action: light.toggle
                        data:
                          entity_id: ${l2_entity}

              - button:
                  id: btn_l3
                  checkable: true
                  styles: light_btn
                  grid_cell_column_pos: 0
                  grid_cell_row_pos: 1
                  grid_cell_x_align: STRETCH
                  grid_cell_y_align: STRETCH
                  widgets:
                    - label:
                        id: lbl_l3
                        align: CENTER
                        text: "${l3_name}\n--"
                  on_click:
                    - homeassistant.action:
                        action: light.toggle
                        data:
                          entity_id: ${l3_entity}

              - button:
                  id: btn_l4
                  checkable: true
                  styles: light_btn
                  grid_cell_column_pos: 1
                  grid_cell_row_pos: 1
                  grid_cell_x_align: STRETCH
                  grid_cell_y_align: STRETCH
                  widgets:
                    - label:
                        id: lbl_l4
                        align: CENTER
                        text: "${l4_name}\n--"
                  on_click:
                    - homeassistant.action:
                        action: light.toggle
                        data:
                          entity_id: ${l4_entity}

